## 第一章 温故而知新

### 线程访问权限

![image-20240206000039196](程序员的自我修养 -- 链接、装载与库.assets/image-20240206000039196.png)





### 线程状态切换

![image-20240206000110583](程序员的自我修养 -- 链接、装载与库.assets/image-20240206000110583.png)







### 可重入情况

![image-20240203223330812](程序员的自我修养 -- 链接、装载与库.assets/image-20240203223330812.png)



### 可重入函数特点

![image-20240203223351952](程序员的自我修养 -- 链接、装载与库.assets/image-20240203223351952.png)



## 第二章 静态链接

### 从源代码到可执行文件过程

![image-20240208161934434](程序员的自我修养 -- 链接、装载与库.assets/image-20240208161934434.png)



![image-20240208161924048](程序员的自我修养 -- 链接、装载与库.assets/image-20240208161924048.png)



### 编译过程

![image-20240208163913326](程序员的自我修养 -- 链接、装载与库.assets/image-20240208163913326.png)



### 词法分析结果

![image-20240209141535411](程序员的自我修养 -- 链接、装载与库.assets/image-20240209141535411.png)





### 编译器前端和后端之分

![image-20240209142500732](程序员的自我修养 -- 链接、装载与库.assets/image-20240209142500732.png)





### 为什么需要链接

![image-20240209142926684](程序员的自我修养 -- 链接、装载与库.assets/image-20240209142926684.png)



### 链接过程分类

![image-20240209143910340](程序员的自我修养 -- 链接、装载与库.assets/image-20240209143910340.png)



### 静态链接过程

![image-20240209144038499](程序员的自我修养 -- 链接、装载与库.assets/image-20240209144038499.png)





## 第三章 目标文件里有什么

### 目标文件段分布

![image-20240209150042685](程序员的自我修养 -- 链接、装载与库.assets/image-20240209150042685.png)



### bss段的作用

![image-20240209150420099](程序员的自我修养 -- 链接、装载与库.assets/image-20240209150420099.png)

并没有占据文件空间，但是在全局的段信息中保留了大小。

![image-20240209150731213](程序员的自我修养 -- 链接、装载与库.assets/image-20240209150731213.png)



### ELF文件常用段

![image-20240209231632114](程序员的自我修养 -- 链接、装载与库.assets/image-20240209231632114.png)



### 如何将二进制文件作为目标文件中的一个段

![image-20240209232119816](程序员的自我修养 -- 链接、装载与库.assets/image-20240209232119816.png)





### 自定义段

![image-20240209232244104](程序员的自我修养 -- 链接、装载与库.assets/image-20240209232244104.png)





### ELF文件结构

![image-20240210172317701](程序员的自我修养 -- 链接、装载与库.assets/image-20240210172317701.png)



### ELF文件类型

![image-20240210172925621](程序员的自我修养 -- 链接、装载与库.assets/image-20240210172925621.png)



### ELF文件头结构成员含义

![image-20240210173929732](程序员的自我修养 -- 链接、装载与库.assets/image-20240210173929732.png)

![image-20240210173938807](程序员的自我修养 -- 链接、装载与库.assets/image-20240210173938807.png)

![image-20240210173948223](程序员的自我修养 -- 链接、装载与库.assets/image-20240210173948223.png)



### 段描述符结构与成员含义

![image-20240210175835408](程序员的自我修养 -- 链接、装载与库.assets/image-20240210175835408.png)

![image-20240210175938796](程序员的自我修养 -- 链接、装载与库.assets/image-20240210175938796.png)



### ELF符号表结构与成员含义

![image-20240210183932754](程序员的自我修养 -- 链接、装载与库.assets/image-20240210183932754.png)

![image-20240210184046313](程序员的自我修养 -- 链接、装载与库.assets/image-20240210184046313.png)





### 特殊符号

![image-20240210193415327](程序员的自我修养 -- 链接、装载与库.assets/image-20240210193415327.png)



### 强符号和弱符号

![image-20240211105130886](程序员的自我修养 -- 链接、装载与库.assets/image-20240211105130886.png)

### 强引用和弱引用

![image-20240211121940772](程序员的自我修养 -- 链接、装载与库.assets/image-20240211121940772.png)



### （问题）弱引用实例并没有得到预想的效果

![image-20240211130641375](程序员的自我修养 -- 链接、装载与库.assets/image-20240211130641375.png)	

### 调试信息格式

![image-20240211131122377](程序员的自我修养 -- 链接、装载与库.assets/image-20240211131122377.png)



## 第四章 静态链接

### 目标文件、可执行文件与进程空间

![image-20240211175403395](程序员的自我修养 -- 链接、装载与库.assets/image-20240211175403395.png)



### Linux下虚拟地址分配

![image-20240211180211418](程序员的自我修养 -- 链接、装载与库.assets/image-20240211180211418.png)

32位程序下是这样。后面有时间可以查查现在的做法。



### 重定位表结构与成员含义

![image-20240211183600847](程序员的自我修养 -- 链接、装载与库.assets/image-20240211183600847.png)



### x86基本重定位类型

![image-20240211184347762](程序员的自我修养 -- 链接、装载与库.assets/image-20240211184347762.png)





### common块的作用

![image-20240211195256668](程序员的自我修养 -- 链接、装载与库.assets/image-20240211195256668.png)



### 如何把未初始化的全局变量不以common块的形式处理

![image-20240211195501139](程序员的自我修养 -- 链接、装载与库.assets/image-20240211195501139.png)



### C/C++程序执行流程

![image-20240211220418228](程序员的自我修养 -- 链接、装载与库.assets/image-20240211220418228.png)



### ABI概念

![image-20240211221039254](程序员的自我修养 -- 链接、装载与库.assets/image-20240211221039254.png)





### -fno-builtin选项的作用

![image-20240212125518180](程序员的自我修养 -- 链接、装载与库.assets/image-20240212125518180.png)



### 链接过程控制方法

![image-20240212164002012](程序员的自我修养 -- 链接、装载与库.assets/image-20240212164002012.png)



### BFD库

![image-20240212190448169](程序员的自我修养 -- 链接、装载与库.assets/image-20240212190448169.png)

​	



## 第六章 可执行文件的装载与进程

### 程序和进程的区别

![image-20240213114603670](程序员的自我修养 -- 链接、装载与库.assets/image-20240213114603670.png)



### Linux进程虚拟地址空间分布

![image-20240213115050471](程序员的自我修养 -- 链接、装载与库.assets/image-20240213115050471.png)



### 装载的方式

![image-20240213121539872](程序员的自我修养 -- 链接、装载与库.assets/image-20240213121539872.png)

具体参见6.2节



### 进程建立

![image-20240213122053046](程序员的自我修养 -- 链接、装载与库.assets/image-20240213122053046.png)



### 建立虚拟空间与可执行文件映射关系过程

![image-20240213122326335](程序员的自我修养 -- 链接、装载与库.assets/image-20240213122326335.png)



### VMA概念

![image-20240213122725781](程序员的自我修养 -- 链接、装载与库.assets/image-20240213122725781.png)



![image-20240213122735337](程序员的自我修养 -- 链接、装载与库.assets/image-20240213122735337.png)



### 视图概念

![image-20240213133724840](程序员的自我修养 -- 链接、装载与库.assets/image-20240213133724840.png)





### 程序表头接口与成员含义

![image-20240213133953245](程序员的自我修养 -- 链接、装载与库.assets/image-20240213133953245.png)



![image-20240213134016600](程序员的自我修养 -- 链接、装载与库.assets/image-20240213134016600.png)







### 进程虚拟空间分布数据格式说明

![image-20240213135046584](程序员的自我修养 -- 链接、装载与库.assets/image-20240213135046584.png)



### 进程VMA区域划分

![image-20240213135451563](程序员的自我修养 -- 链接、装载与库.assets/image-20240213135451563.png)

![image-20240213135541153](程序员的自我修养 -- 链接、装载与库.assets/image-20240213135541153.png)





### malloc申请大小影响因素

![image-20240213170636025](程序员的自我修养 -- 链接、装载与库.assets/image-20240213170636025.png)

这里我本地测试出来是10G。这个后面可以看一下。单次malloc的内容上限。



### prog 123 进程初始化堆栈

![image-20240213185010809](程序员的自我修养 -- 链接、装载与库.assets/image-20240213185010809.png)

![image-20240213185153416](程序员的自我修养 -- 链接、装载与库.assets/image-20240213185153416.png)





### Linux内核装载ELF过程

参考第6.5节



### WindowsPE的装载

暂时不关注Windows的装载。先不看了





## 第七章 动态链接

### 静态链接的缺点

![image-20240213192237949](程序员的自我修养 -- 链接、装载与库.assets/image-20240213192237949.png)



### 动态链接的基本思想

![image-20240213192804956](程序员的自我修养 -- 链接、装载与库.assets/image-20240213192804956.png)





### 动态链接和静态链接内存分布的比较

![image-20240213193104735](程序员的自我修养 -- 链接、装载与库.assets/image-20240213193104735.png)

![image-20240213193053488](程序员的自我修养 -- 链接、装载与库.assets/image-20240213193053488.png)



### 链接时重定位和装载时重定位

![image-20240214125013366](程序员的自我修养 -- 链接、装载与库.assets/image-20240214125013366.png)



### 地址无关代码的基本思想

![image-20240214125157715](程序员的自我修养 -- 链接、装载与库.assets/image-20240214125157715.png)



### 地址无关代码引用方式

![image-20240214131319795](程序员的自我修养 -- 链接、装载与库.assets/image-20240214131319795.png)



### -fpic和-fPIC的区别

![image-20240214131442107](程序员的自我修养 -- 链接、装载与库.assets/image-20240214131442107.png)

### 如何区分一个DSO是否是PIC

![image-20240214131806539](程序员的自我修养 -- 链接、装载与库.assets/image-20240214131806539.png)

### PIE

![image-20240214131936719](程序员的自我修养 -- 链接、装载与库.assets/image-20240214131936719.png)

### 不同进程和线程访问共享库中的全局变量表现

![image-20240216113733525](程序员的自我修养 -- 链接、装载与库.assets/image-20240216113733525.png)

![image-20240216113739398](程序员的自我修养 -- 链接、装载与库.assets/image-20240216113739398.png)

### 影响动态链接性能的两个主要问题

![image-20240216114753226](程序员的自我修养 -- 链接、装载与库.assets/image-20240216114753226.png)



### 延迟绑定和PLT概念

![image-20240216115759216](程序员的自我修养 -- 链接、装载与库.assets/image-20240216115759216.png)

![image-20240216115828240](程序员的自我修养 -- 链接、装载与库.assets/image-20240216115828240.png)

### PLT数据结构

![image-20240216115851212](程序员的自我修养 -- 链接、装载与库.assets/image-20240216115851212.png)

![image-20240216115858885](程序员的自我修养 -- 链接、装载与库.assets/image-20240216115858885.png)



![image-20240216120108845](程序员的自我修养 -- 链接、装载与库.assets/image-20240216120108845.png)



### ELF动态链接过程概述

![image-20240216122021399](程序员的自我修养 -- 链接、装载与库.assets/image-20240216122021399.png)



### 动态链接器路径问题

![image-20240216123050883](程序员的自我修养 -- 链接、装载与库.assets/image-20240216123050883.png)



###  .dynamic段的数据结构与含义

![image-20240216123725506](程序员的自我修养 -- 链接、装载与库.assets/image-20240216123725506.png)





![image-20240216123800268](程序员的自我修养 -- 链接、装载与库.assets/image-20240216123800268.png)



### linux-gate.so.1

![image-20240216124702068](程序员的自我修养 -- 链接、装载与库.assets/image-20240216124702068.png)



65位下好像已经没有这个文件了。

![image-20240216124834093](程序员的自我修养 -- 链接、装载与库.assets/image-20240216124834093.png)





### dynsym  -- 动态符号表

![image-20240216205230318](程序员的自我修养 -- 链接、装载与库.assets/image-20240216205230318.png)



![image-20240216205300191](程序员的自我修养 -- 链接、装载与库.assets/image-20240216205300191.png)





### 动态链接辅助信息数组结构

![image-20240216211536727](程序员的自我修养 -- 链接、装载与库.assets/image-20240216211536727.png)

![image-20240216211623210](程序员的自我修养 -- 链接、装载与库.assets/image-20240216211623210.png)

![image-20240216211630049](程序员的自我修养 -- 链接、装载与库.assets/image-20240216211630049.png)





### 动态链接进程初始化堆栈信息

![image-20240216212401312](程序员的自我修养 -- 链接、装载与库.assets/image-20240216212401312.png)





### 动态链接步骤

![image-20240216223607970](程序员的自我修养 -- 链接、装载与库.assets/image-20240216223607970.png)



### 动态链接器自举

![image-20240216224014210](程序员的自我修养 -- 链接、装载与库.assets/image-20240216224014210.png)





### 全局符号介入与地址无关代码

![image-20240310104921968](程序员的自我修养 -- 链接、装载与库.assets/image-20240310104921968.png)	

![image-20240217105015156](程序员的自我修养 -- 链接、装载与库.assets/image-20240217105015156.png)



如果模块内部定义了一个static的函数，模块外部也有一个全局的同名函数，模块内调用时会使用哪个函数呢？这个后面可以看一下。



### 动态链接初始化

![image-20240217110217288](程序员的自我修养 -- 链接、装载与库.assets/image-20240217110217288.png)



### 动态链接器实现的几个问题

![image-20240217111343672](程序员的自我修养 -- 链接、装载与库.assets/image-20240217111343672.png)



### 显式运行时链接

![image-20240217115206254](程序员的自我修养 -- 链接、装载与库.assets/image-20240217115206254.png)



![image-20240217115223838](程序员的自我修养 -- 链接、装载与库.assets/image-20240217115223838.png)



### 运行时链接函数原型与简单说明

![image-20240217115828944](程序员的自我修养 -- 链接、装载与库.assets/image-20240217115828944.png)

![image-20240217115857072](程序员的自我修养 -- 链接、装载与库.assets/image-20240217115857072.png)

![image-20240217120459840](程序员的自我修养 -- 链接、装载与库.assets/image-20240217120459840.png)

![image-20240217120606306](程序员的自我修养 -- 链接、装载与库.assets/image-20240217120606306.png)



### 符号优先级  -- 装载序列和依赖序列

![image-20240217120418067](程序员的自我修养 -- 链接、装载与库.assets/image-20240217120418067.png)





## 第八章 Linux共享库的组织

### 共享库的兼容更新方式

![image-20240310004047739](程序员的自我修养 -- 链接、装载与库.assets/image-20240310004047739.png)![image-20240310004048003](程序员的自我修养 -- 链接、装载与库.assets/image-20240310004048003.png)



​	![image-20240217193253142](程序员的自我修养 -- 链接、装载与库.assets/image-20240217193253142.png)



![image-20240217193701066](程序员的自我修养 -- 链接、装载与库.assets/image-20240217193701066.png)



### C++ ABI兼容注意事项

![image-20240217193920127](程序员的自我修养 -- 链接、装载与库.assets/image-20240217193920127.png)



### Linux共享库命名规则

![image-20240310004353573](程序员的自我修养 -- 链接、装载与库.assets/image-20240310004353573.png)

![image-20240310004536929](程序员的自我修养 -- 链接、装载与库.assets/image-20240310004536929.png)



### 对linux共享版本号介绍的文章

```
Library Interface Versioning in *Solaris* and *Linux*
```

https://usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/browndavid/browndavid.pdf

https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/browndavid/browndavid_html/index.html





### Linux下的SO-NAME

原书8.1.3节



### 库链接名

![image-20240310010617583](程序员的自我修养 -- 链接、装载与库.assets/image-20240310010617583.png)

默认动态链接





### 次版本号交会问题

![image-20240310095847603](程序员的自我修养 -- 链接、装载与库.assets/image-20240310095847603.png)

### 共享库的系统路径

​	![image-20240310102329603](程序员的自我修养 -- 链接、装载与库.assets/image-20240310102329603.png)

[Filesystem Hierarchy Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)



### 系统库查找过程

![image-20240310103625989](程序员的自我修养 -- 链接、装载与库.assets/image-20240310103625989.png)

![image-20240310103711267](程序员的自我修养 -- 链接、装载与库.assets/image-20240310103711267.png)

![image-20240310104319220](程序员的自我修养 -- 链接、装载与库.assets/image-20240310104319220.png)



[Why LD_LIBRARY_PATH is bad](http://xahlee.info/UnixResource_dir/_/ldpath.html)



### LD_PRELOAD

![image-20240310105057186](程序员的自我修养 -- 链接、装载与库.assets/image-20240310105057186.png)

![image-20240310105117889](程序员的自我修养 -- 链接、装载与库.assets/image-20240310105117889.png)	

### LD_DEBUG

![image-20240310105808724](程序员的自我修养 -- 链接、装载与库.assets/image-20240310105808724.png)

![image-20240310105833681](程序员的自我修养 -- 链接、装载与库.assets/image-20240310105833681.png)



![image-20240310105847072](程序员的自我修养 -- 链接、装载与库.assets/image-20240310105847072.png)



### 共享库的创建和安装

参见原书8.6节



### 编译时指定共享库位置

![image-20240310111638344](程序员的自我修养 -- 链接、装载与库.assets/image-20240310111638344.png)

后面找时间来搞清楚这几个参数的用法



### 共享库构造和析构函数

![image-20240310112002660](程序员的自我修养 -- 链接、装载与库.assets/image-20240310112002660.png)

## 第十章 内存

### 程序环境

![image-20240310113747841](程序员的自我修养 -- 链接、装载与库.assets/image-20240310113747841.png)



### Linux内存经典布局

![image-20240310164959588](程序员的自我修养 -- 链接、装载与库.assets/image-20240310164959588.png)



### 段错误的常见原因

![image-20240310170143907](程序员的自我修养 -- 链接、装载与库.assets/image-20240310170143907.png)



### 为什么乱码会是“烫”

![image-20240310172531183](程序员的自我修养 -- 链接、装载与库.assets/image-20240310172531183.png)

![image-20240310172539427](程序员的自我修养 -- 链接、装载与库.assets/image-20240310172539427.png)



### i386标准进入和退出指令序列与特殊情况

![image-20240310172827204](程序员的自我修养 -- 链接、装载与库.assets/image-20240310172827204.png)

![image-20240310172839036](程序员的自我修养 -- 链接、装载与库.assets/image-20240310172839036.png)

![image-20240310172845362](程序员的自我修养 -- 链接、装载与库.assets/image-20240310172845362.png)





### 调用惯例包含内容

![image-20240310182051543](程序员的自我修养 -- 链接、装载与库.assets/image-20240310182051543.png)



### C语言默认调用惯例

![image-20240310182137767](程序员的自我修养 -- 链接、装载与库.assets/image-20240310182137767.png)	



### 主要调用惯例内容

![image-20240310183643107](程序员的自我修养 -- 链接、装载与库.assets/image-20240310183643107.png)



### 典型函数栈帧

![image-20240310185628951](程序员的自我修养 -- 链接、装载与库.assets/image-20240310185628951.png)

### 为什么要有堆

![image-20240320230552506](程序员的自我修养 -- 链接、装载与库.assets/image-20240320230552506.png)



### Linux两个用于对空间分配的系统调用

![image-20240321235455359](程序员的自我修养 -- 链接、装载与库.assets/image-20240321235455359.png)



### malloc一次能够申请的最大空间

![image-20240322000310716](程序员的自我修养 -- 链接、装载与库.assets/image-20240322000310716.png)

​	![image-20240322000321565](程序员的自我修养 -- 链接、装载与库.assets/image-20240322000321565.png)

![image-20240322000341642](程序员的自我修养 -- 链接、装载与库.assets/image-20240322000341642.png)



### 堆分配算法

#### 空闲链表

![image-20240322232903440](程序员的自我修养 -- 链接、装载与库.assets/image-20240322232903440.png)

![image-20240322232914037](程序员的自我修养 -- 链接、装载与库.assets/image-20240322232914037.png)

#### 位图

![image-20240322233633881](程序员的自我修养 -- 链接、装载与库.assets/image-20240322233633881.png)

![image-20240322233645865](程序员的自我修养 -- 链接、装载与库.assets/image-20240322233645865.png)

#### 对象池

![image-20240322234144193](程序员的自我修养 -- 链接、装载与库.assets/image-20240322234144193.png)



### glibc的堆分配算法

![image-20240322234242647](程序员的自我修养 -- 链接、装载与库.assets/image-20240322234242647.png)

## 第十一章 运行库

### 入口函数（入口点）

![image-20240323225548629](程序员的自我修养 -- 链接、装载与库.assets/image-20240323225548629.png)

### Glibc的入口函数实现

参见11.1.2节



### 什么是IO

​	![image-20240326235024628](程序员的自我修养 -- 链接、装载与库.assets/image-20240326235024628.png)





![image-20240326235045367](程序员的自我修养 -- 链接、装载与库.assets/image-20240326235045367.png)



### FILE、fd、打开文件表与打开文件对象的关系

![image-20240327000122675](程序员的自我修养 -- 链接、装载与库.assets/image-20240327000122675.png)



### IO初始化的职责

![image-20240327000154298](程序员的自我修养 -- 链接、装载与库.assets/image-20240327000154298.png)

### 运行时库及其功能

![image-20240327000928174](程序员的自我修养 -- 链接、装载与库.assets/image-20240327000928174.png)

![image-20240327000947375](程序员的自我修养 -- 链接、装载与库.assets/image-20240327000947375.png)

### C语言标准库的基本函数集合

![image-20240328000532782](程序员的自我修养 -- 链接、装载与库.assets/image-20240328000532782.png)

![image-20240328000549691](程序员的自我修养 -- 链接、装载与库.assets/image-20240328000549691.png)



### C语言变长参数实现

![image-20240401002251105](程序员的自我修养 -- 链接、装载与库.assets/image-20240401002251105.png)

![image-20240401002326593](程序员的自我修养 -- 链接、装载与库.assets/image-20240401002326593.png)

![image-20240401002353372](程序员的自我修养 -- 链接、装载与库.assets/image-20240401002353372.png)



真实实现：
![image-20240401003358064](程序员的自我修养 -- 链接、装载与库.assets/image-20240401003358064.png)





### C语言运行库的作用

![image-20240402000811865](程序员的自我修养 -- 链接、装载与库.assets/image-20240402000811865.png)







### glibc发布版本组成

![image-20240402001555407](程序员的自我修养 -- 链接、装载与库.assets/image-20240402001555407.png)

### crt1.o、crti.o、crtn.o的作用

![image-20240427120327250](程序员的自我修养 -- 链接、装载与库.assets/image-20240427120327250.png)

![image-20240427120403376](程序员的自我修养 -- 链接、装载与库.assets/image-20240427120403376.png)



### crtbeginT.o、libgcc.a、libgcc_eh.a、crtend.o的作用

![image-20240504234441602](程序员的自我修养 -- 链接、装载与库.assets/image-20240504234441602.png)



### 线程的访问权限

![image-20240505111535455](程序员的自我修养 -- 链接、装载与库.assets/image-20240505111535455.png)



### CRT多线程改进

![image-20240505120246070](程序员的自我修养 -- 链接、装载与库.assets/image-20240505120246070.png)



## 第十二章 系统调用和API

### 什么是系统调用

![image-20240506233800332](程序员的自我修养 -- 链接、装载与库.assets/image-20240506233800332.png)

### Linux下的系统调用

![image-20240519115848007](程序员的自我修养 -- 链接、装载与库.assets/image-20240519115848007.png)

![image-20240519115856398](程序员的自我修养 -- 链接、装载与库.assets/image-20240519115856398.png)



### man指令的使用方法

参考

https://www.runoob.com/linux/linux-comm-man.html#:~:text=Linux%20man%20%E5%91%BD%E4%BB%A4%20Linux%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%20Linux%20man%20%E5%91%BD%E4%BB%A4%E6%98%AF,man%20%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%82%A8%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%85%B3%E4%BA%8E%E7%89%B9%E5%AE%9A%E5%91%BD%E4%BB%A4%E6%88%96%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E3%80%82%20%E8%AF%AD%E6%B3%95man%20%5B%E9%80%89%E9%A1%B9%5D%20%5B%E8%8A%82%E5%8F%B7%5D%20%E5%91%BD%E4%BB%A4%2F%E4%B8%BB%E9%A2%98%20%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%89%E9%A1%B9%E5%8C%85%E6%8B%AC%EF%BC%9A%20-f%EF%BC%9A%E6%98%BE%E7%A4%BA%E4%B8%8E%E6%8C%87%E5%AE%9A%E5%85%B3%E9%94%AE%E5%AD%97%E7%9B%B8%E5%85%B3%E7%9A%84%E6%89%8B%E5%86%8C%E9%A1%B5%E9%9D%A2%E3%80%82



![image-20240519120104258](程序员的自我修养 -- 链接、装载与库.assets/image-20240519120104258.png)



### 系统调用的缺点

![image-20240528003539370](程序员的自我修养 -- 链接、装载与库.assets/image-20240528003539370.png)



### 运行库的优缺点

![image-20240528003556701](程序员的自我修养 -- 链接、装载与库.assets/image-20240528003556701.png)

![image-20240528003608305](程序员的自我修养 -- 链接、装载与库.assets/image-20240528003608305.png)



### 特权级

![image-20240528004450630](程序员的自我修养 -- 链接、装载与库.assets/image-20240528004450630.png)



### 中断

![image-20240528004521606](程序员的自我修养 -- 链接、装载与库.assets/image-20240528004521606.png)

### 中断属性

![image-20240528004624910](程序员的自我修养 -- 链接、装载与库.assets/image-20240528004624910.png)

### 软件中断和硬件中断

![image-20240528004704679](程序员的自我修养 -- 链接、装载与库.assets/image-20240528004704679.png)

### 中断如何实现系统调用

![image-20240528004805290](程序员的自我修养 -- 链接、装载与库.assets/image-20240528004805290.png)

### fork系统调用流程

![image-20240529005908201](程序员的自我修养 -- 链接、装载与库.assets/image-20240529005908201.png)

### 基于int的Linux的经典系统调用实现

书本12.2.2节

- 触发中断
- 切换堆栈
- 中断处理程序
- 





### 系统调用时内核栈和用户栈的转换

![image-20240529235208092](程序员的自我修养 -- 链接、装载与库.assets/image-20240529235208092.png)



### i386中断调用流程

![image-20240530000201166](程序员的自我修养 -- 链接、装载与库.assets/image-20240530000201166.png)

### i386中断向量表源码地址

![image-20240530000448587](程序员的自我修养 -- 链接、装载与库.assets/image-20240530000448587.png)

![image-20240530000722083](程序员的自我修养 -- 链接、装载与库.assets/image-20240530000722083.png)

![image-20240530000900883](程序员的自我修养 -- 链接、装载与库.assets/image-20240530000900883.png)

![image-20240530001125979](程序员的自我修养 -- 链接、装载与库.assets/image-20240530001125979.png)

### Linux系统调用流程

![image-20240530001236109](程序员的自我修养 -- 链接、装载与库.assets/image-20240530001236109.png)



### Linux系统调用中如何向内核传递参数

![image-20240530001558126](程序员的自我修养 -- 链接、装载与库.assets/image-20240530001558126.png)







### Linux的新型系统调用机制

![image-20240601180407223](程序员的自我修养 -- 链接、装载与库.assets/image-20240601180407223.png)



![image-20240601184643136](程序员的自我修养 -- 链接、装载与库.assets/image-20240601184643136.png)

### 虚拟动态共享库(VDSO)

![image-20240601180452477](程序员的自我修养 -- 链接、装载与库.assets/image-20240601180452477.png)



```
dd if=/proc/526953/mem of=./linux-gate.dso bs=4096 skip=4503599627367936 count=1
```





## 第十三章 运行库实现

### 按页需求分配

![image-20240602114645708](程序员的自我修养 -- 链接、装载与库.assets/image-20240602114645708.png)



### miniCRT编译选项含义

![image-20240629160303324](程序员的自我修养 -- 链接、装载与库.assets/image-20240629160303324.png) 



### C++中的操作符含义

![image-20240727121802561](程序员的自我修养 -- 链接、装载与库.assets/image-20240727121802561.png)



### C++ new和delete本身不负责构造和析构

![image-20240727122527576](程序员的自我修养 -- 链接、装载与库.assets/image-20240727122527576.png)



### mini CRT++ 编译选项含义

 	![image-20240727174658181](程序员的自我修养 -- 链接、装载与库.assets/image-20240727174658181.png)





## 附录信息

### 字节序介绍

附录A1



### elf常见段

附录A2





### 常用开发工具命令行参考

附录A3







## 一些体会

- 要分清楚哪些事情是编译器做的，哪些事情是运行库做的。

## 结尾	



```
常用换算：
0x400  = 2^10 = 1k

0x1000 = 2^12 = 2^2 * 2^10 = 4k

0x100000 = 2^20 = 1M

0x40000000 = 2^30 = 1G

0x08048000 = 2^27 + 2^18 + 2^15 = 2^7M + 2^8K + 2^5K = 128M + 256k + 32k = 128M + 288k
```



书中关于windows的相关实现我都没有看。后面如果有需要再看吧。



